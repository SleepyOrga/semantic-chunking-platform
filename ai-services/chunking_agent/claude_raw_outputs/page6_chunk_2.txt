[
  {
    "section_title": "Residual Learning Reformulation",
    "content": "the input and output are of the same dimensions). So rather than expect stacked layers to approximate $\\mathcal{H}(\\mathbf{x})$ , we explicitly let these layers approximate a residual function $\\mathcal{F}(\\mathbf{x}) := \\mathcal{H}(\\mathbf{x}) - \\mathbf{x}$ . The original function thus becomes $\\mathcal{F}(\\mathbf{x}) + \\mathbf{x}$ . Although both forms should be able to asymptotically approximate the desired functions (as hypothesized), the case of learning might be different.",
    "tags": ["residual learning", "function approximation", "neural networks", "mathematical formulation"]
  },
  {
    "section_title": "Degradation Problem Motivation",
    "content": "This reformulation is motivated by the counterintuitive phenomena about the degradation problem (Fig. 1 , left). As we discussed in the introduction, if the added layers can be constructed as identity mappings, a deeper model should have training error no greater than its shallower counterpart. The degradation problem suggests that the solvers might have difficulties in approximating identity mappings by multiple nonlinear layers.",
    "tags": ["degradation problem", "deep learning", "identity mapping", "training error", "optimization"]
  },
  {
    "section_title": "Identity Mapping Solution",
    "content": "With the residual learning reformulation, if identity mappings are optimal, the solvers may simply drive the weights of the multiple nonlinear layers toward zero to approach identity mappings. In real cases, it is unlikely that identity mappings are optimal, but our reformulation may help to precondition the problem.",
    "tags": ["identity mapping", "optimization", "weight initialization", "preconditioning", "residual learning"]
  },
  {
    "section_title": "Learning Efficiency Hypothesis",
    "content": "If the optimal function is closer to an identity mapping than to a zero mapping, it should be easier for the solver to find the perturbations with reference to an identity mapping, than to learn the function as a new one. We show by experiments (Fig. 7 ) that the learned residual functions in general have small responses, suggesting that identity mappings provide reasonable preconditioning.",
    "tags": ["learning efficiency", "optimization", "experimental validation", "small responses", "preconditioning"]
  },
  {
    "section_title": "Building Block Definition",
    "content": "$We adopt residual learning to every few stacked layers. \\\\ A building block is shown in Fig. 2 . Formally, in this paper \\\\ we consider a building block defined as: \\\\ $$ \\\\ \\mathbf{y} = \\mathcal{F}(\\mathbf{x}, \\{W_i\\}) + \\mathbf{x}. \\\\ \\eqno(1) \\\\ $$",
    "tags": ["building block", "residual block", "mathematical definition", "architecture design"]
  },
  {
    "section_title": "Function Components Explanation",
    "content": "Here $\\mathbf{x}$ and $\\mathbf{y}$ are the input and output vectors of the layers considered. The function $\\mathcal{F}(\\mathbf{x},\\{W_i\\})$ represents the residual mapping to be learned. For the example in Fig. 2 that has two layers, $\\mathcal{F}=W_2\\sigma(W_1\\mathbf{x})$ in which $\\sigma$ denotes ReLU [29] and the biases are omitted for simplifying notations.",
    "tags": ["input output", "residual mapping", "relu activation", "weight matrices", "notation"]
  },
  {
    "section_title": "Shortcut Connection Implementation",
    "content": "The operation $\\mathcal{F} + \\mathbf{x}$ is performed by a shortcut connection and element-wise addition. We adopt the second nonlinearity after the addition ( i.e. , $\\sigma(\\mathbf{y})$ , see Fig. 2 ). The shortcut connections in Eqn.( 1 ) introduce neither extra parameter nor computation complexity.",
    "tags": ["shortcut connection", "element-wise addition", "nonlinearity", "computational efficiency", "parameter efficiency"]
  },
  {
    "section_title": "Comparison Advantages",
    "content": "This is not only attractive in practice but also important in our comparisons between plain and residual networks. We can fairly compare plain/residual networks that simultaneously have the same number of parameters, depth, width, and computational cost (except for the negligible element-wise addition).",
    "tags": ["fair comparison", "computational cost", "network parameters", "depth", "width"]
  },
  {
    "section_title": "Dimension Matching Problem",
    "content": "The dimensions of $\\mathbf{x}$ and $\\mathcal{F}$ must be equal in Eqn.( 1 ). If this is not the case ( e.g. , when changing the input/output channels), we can perform a linear projection $W_s$ by the shortcut connections to match the dimensions: $$ \\\\ \\mathbf{y} = \\mathcal{F}(\\mathbf{x}, \\{W_i\\}) + W_s \\mathbf{x}. \\\\ $$",
    "tags": ["dimension matching", "linear projection", "channel changes", "shortcut connections"]
  },
  {
    "section_title": "Identity Mapping Preference",
    "content": "We can also use a square matrix $W_s$ in Eqn.( 1 ). But we will show by experiments that the identity mapping is sufficient for addressing the degradation problem and is economical, and thus $W_s$ is only used when matching dimensions.",
    "tags": ["identity mapping", "square matrix", "experimental results", "economical solution", "degradation problem"]
  },
  {
    "section_title": "Residual Function Flexibility",
    "content": "The form of the residual function $\\mathcal{F}$ is flexible. Experiments in this paper involve a function $\\mathcal{F}$ that has two or three layers (Fig. 5 ), while more layers are possible. But if $\\mathcal{F}$ has only a single layer, Eqn.( 1 ) is similar to a linear layer: $\\boldsymbol{y}=W_1\\mathbf{x}+\\mathbf{x}$ , for which we have not observed advantages.",
    "tags": ["residual function", "flexibility", "layer count", "linear layer", "experimental observations"]
  },
  {
    "section_title": "Convolutional Layer Application",
    "content": "We also note that although the above notations are about fully-connected layers for simplicity, they are applicable to convolutional layers. The function $\\mathcal{F}(\\mathbf{x},\\{W_i\\})$ can represent multiple convolutional layers. The element-wise addition is performed on two feature maps, channel by channel,",
    "tags": ["convolutional layers", "fully-connected layers", "feature maps", "channel-wise addition", "generalization"]
  },
  {
    "section_title": "Network Architecture Testing",
    "content": "We have tested various plain/residual nets, and have observed consistent phenomena. To provide instances for discussion, we describe two models for ImageNet as follows.",
    "tags": ["network architecture", "testing", "consistent phenomena", "imagenet", "model comparison"]
  },
  {
    "section_title": "Plain Network Design Philosophy",
    "content": "Plain Network. Our plain baselines (Fig. 3 , middle) are mainly inspired by the philosophy of VGG nets [40] (Fig. 3 , left). The convolutional layers mostly have 3 $\\times$ 3 filters and follow two simple design rules:",
    "tags": ["plain network", "vgg nets", "convolutional layers", "3x3 filters", "design rules"]
  },
  {
    "section_title": "Plain Network Design Rules",
    "content": "(i) for the same output feature map size, the layers have the same number of filters; and (ii) if the feature map size is halved, the number of filters is doubled so as to preserve the time complexity per layer.",
    "tags": ["design rules", "feature map size", "filter count", "time complexity", "architectural principles"]
  },
  {
    "section_title": "Plain Network Structure",
    "content": "We perform downsampling directly by convolutional layers that have a stride of 2. The network ends with a global average pooling layer and a 1000-way fully-connected layer with softmax. The total number of weighted layers is 34 in Fig. 3 (middle).",
    "tags": ["downsampling", "stride", "global average pooling", "softmax", "34 layers"]
  },
  {
    "section_title": "Computational Efficiency Comparison",
    "content": "It is worth noticing that our model has fewer filters and lower complexity than VGG nets [40] (Fig. 3 , left). Our 34layer baseline has 3.6 billion FLOPs (multiply-adds), which is only 18 % of VGG-19 (19.6 billion FLOPs).",
    "tags": ["computational efficiency", "flops", "vgg comparison", "model complexity", "multiply-adds"]
  },
  {
    "section_title": "Open Research Question",
    "content": "$^{2}$ This hypothesis, however, is still an open question. See [28] . 722 ---",
    "tags": ["open question", "hypothesis", "research", "reference"]
  },
  {
    "section_title": "Network Architecture Examples",
    "content": "![Figure](figures/page_6_page_004_figure_000.png) Figure 3. Example network architectures for ImageNet. Left : the VGG-19 model [40] (19.6 billion FLOPs) as a reference. Middle : a plain network with 34 parameter layers (3.6 billion FLOPs). Right : a residual network with 34 parameter layers (3.6 billion FLOPs). The dotted shortcuts increase dimensions. Table I shows more details and other variants.",
    "tags": ["figure", "network architectures", "imagenet", "vgg-19", "plain network", "residual network", "shortcuts"]
  },
  {
    "section_title": "Residual Network Construction",
    "content": "Residual Network. Based on the above plain network, we insert shortcut connections (Fig. 3 , right) which turn the network into its counterpart residual version. The identity shortcuts (Eqn.( 1 )) can be directly used when the input and output are of the same dimensions (solid line shortcuts in Fig. 3 ).",
    "tags": ["residual network", "shortcut connections", "identity shortcuts", "same dimensions", "solid line shortcuts"]
  },
  {
    "section_title": "Dimension Increase Handling",
    "content": "When the dimensions increase (dotted line shortcuts in Fig. 3 ), we consider two options: (A) The shortcut still performs identity mapping, with extra zero entries padded for increasing dimensions. This option introduces no extra parameter; (B) The projection shortcut in Eqn.( 2 ) is used to match dimensions (done by 1 $\\times$ 1 convolutions).",
    "tags": ["dimension increase", "dotted shortcuts", "identity mapping", "zero padding", "projection shortcut", "1x1 convolutions"]
  },
  {
    "section_title": "Cross-Size Feature Maps",
    "content": "For both options, when the shortcuts go across feature maps of two sizes, they are performed with a",
    "tags": ["feature maps", "cross-size", "shortcuts", "implementation"]
  }
]